package net.sjrx.intellij.plugins.systemdunitfiles.inspections;

import com.intellij.codeInspection.LocalInspectionTool;
import com.intellij.codeInspection.ProblemHighlightType;
import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.psi.PsiElementVisitor;
import com.intellij.psi.PsiFile;
import com.intellij.psi.util.PsiTreeUtil;
import net.sjrx.intellij.plugins.systemdunitfiles.UnitFileLanguage;
import net.sjrx.intellij.plugins.systemdunitfiles.psi.UnitFile;
import net.sjrx.intellij.plugins.systemdunitfiles.psi.UnitFilePropertyType;
import net.sjrx.intellij.plugins.systemdunitfiles.psi.UnitFileSectionGroups;
import net.sjrx.intellij.plugins.systemdunitfiles.psi.UnitFileVisitor;
import net.sjrx.intellij.plugins.systemdunitfiles.semanticdata.SemanticDataRepository;
import org.jetbrains.annotations.NotNull;

/**
 * The purpose of this inspection is to catch any warnings that may be generated by systemd when processing a unit file.
 *
 * <p>The rules state:
 *
 * <pre>
 * Unit files may contain additional options on top of those listed here. If systemd encounters an unknown option,
 * it will write a warning log message but continue loading the unit. If an option or section name is prefixed with X-,
 * it is ignored completely by systemd. Options within an ignored section do not need the prefix.
 * Applications may use this to include additional information in the unit files.
 * </pre> (Source: https://www.freedesktop.org/software/systemd/man/systemd.unit.html#)
 */
public class UnknownKeyInSectionInspection extends LocalInspectionTool {

  private static final String IGNORED_SECTION_OR_KEY_PREFIX = "X-";
  static final String INSPECTION_TOOL_TIP_TEXT =
          "This key is unrecognized which will cause systemd to generate a warning when loading this unit.";

  @NotNull
  @Override
  public PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder, boolean isOnTheFly) {
    PsiFile file = holder.getFile();
    if (!(file instanceof UnitFile) || !file.getLanguage().isKindOf(UnitFileLanguage.INSTANCE)) {
      return PsiElementVisitor.EMPTY_VISITOR;
    }
    return new MyVisitor(holder);
  }

  private static class MyVisitor extends UnitFileVisitor {
    @NotNull
    private final ProblemsHolder holder;

    public MyVisitor(@NotNull ProblemsHolder holder) {
      this.holder = holder;
    }

    @Override
    public void visitPropertyType(@NotNull UnitFilePropertyType property) {
      String key = property.getKey();
      if (key.startsWith(IGNORED_SECTION_OR_KEY_PREFIX)) {
        return;
      }

      UnitFileSectionGroups section = PsiTreeUtil.getParentOfType(property, UnitFileSectionGroups.class);
      if (section == null) {
        return;
      }

      String sectionName = section.getSectionName();
      if (sectionName.startsWith(IGNORED_SECTION_OR_KEY_PREFIX)) {
        return;
      }

      SemanticDataRepository sdr = SemanticDataRepository.getInstance();

      if (!sdr.getAllowedKeywordsInSectionFromValidators(sectionName).contains(key)) {
        // TODO Figure out what highlight to use
        holder.registerProblem(property.getKeyNode().getPsi(), INSPECTION_TOOL_TIP_TEXT, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
      }
    }
  }
}
